# Biome System
*Created: 2025-06-05 22:59*
*Last Updated: 2025-06-05 22:59*

## Overview
This document outlines the biome system design for Voxel Castle. The biome system will enable diverse world environments with different terrain, vegetation, and visual characteristics.

## Design Goals

1. **Environmental Diversity**: Create varied and interesting landscapes
2. **Seamless Transitions**: Smooth blending between biome types
3. **Deterministic Placement**: Consistent biome generation from seeds
4. **Performance Efficiency**: Fast biome determination during generation
5. **Extensibility**: Easy addition of new biome types

## Core Components

### BiomeType Enumeration

**Purpose**: Define all available biome types

**Initial Biome Types**:
- [ ] **Plains**: Flat grasslands with occasional trees
- [ ] **Forest**: Dense tree coverage with varied heights
- [ ] **Mountains**: High elevation with stone outcrops
- [ ] **Desert**: Sandy terrain with cacti
- [ ] **Ocean**: Water bodies with underwater features
- [ ] **Tundra**: Cold terrain with snow and ice
- [ ] **Jungle**: Dense, tall vegetation
- [ ] **Savanna**: Sparse trees and tall grass

### BiomeGenerator Class

**Purpose**: Generate and determine biomes for world coordinates

**Key Functionality**:
- [ ] Seed-based biome placement
- [ ] Temperature and humidity noise maps
- [ ] Biome selection based on climate parameters
- [ ] Biome blending at boundaries
- [ ] Special biome placement (rare biomes)

### BiomeData System

**Purpose**: Store biome-specific generation parameters

**Key Functionality**:
- [ ] Terrain modification parameters
- [ ] Vegetation types and density
- [ ] Block type selection
- [ ] Structure spawn rates
- [ ] Climate characteristics

## Implementation Details

### Biome Determination Process

The process for determining biomes will use multiple noise layers:

1. **Temperature Map**: Global temperature variation
2. **Humidity Map**: Global humidity/rainfall variation
3. **Biome Selection**: Using temperature and humidity as coordinates on a biome chart
4. **Special Case Handling**: Override for special biomes like mountains
5. **Blending**: Smooth transitions at biome boundaries

### Biome Chart

Biomes will be selected using a 2D temperature-humidity chart:

```
           Cold  |  Cool  |  Temperate  |  Warm  |  Hot
        ─────────┼────────┼─────────────┼────────┼────────
  Dry   | Tundra | Plains |    Savanna  | Desert | Desert
        │        │        │             │        │
Medium  | Taiga  | Plains |    Plains   | Savanna| Savanna
        │        │        │             │        │
 Wet    | Taiga  | Forest |    Forest   | Jungle | Jungle
```

### Biome Blending

For smooth transitions between biomes:

1. **Edge Detection**: Identify proximity to biome boundaries
2. **Gradient Weighting**: Weight block selection by distance to boundary
3. **Terrain Blending**: Gradual change in height characteristics
4. **Vegetation Blending**: Mixed vegetation near boundaries

## Technical Approach

### Temperature and Humidity Generation

```
// Pseudocode (not actual implementation)
float getTemperature(int64_t x, int64_t z, uint64_t seed) {
    // Use seed to initialize noise generator
    // Apply large-scale noise for temperature gradient
    // Return value in range [0.0, 1.0]
}

float getHumidity(int64_t x, int64_t z, uint64_t seed) {
    // Similar to temperature but with different noise parameters
    // Can include altitude effects on humidity
}
```

### Biome Selection Logic

```
// Pseudocode (not actual implementation)
BiomeType getBiome(float temperature, float humidity) {
    // Map temperature and humidity to biome chart
    // Handle special cases and edge conditions
    // Return appropriate biome type
}
```

## Transition Strategy

### Phase 1: Basic Biome Framework
- [ ] Implement BiomeType enumeration
- [ ] Create temperature and humidity generation
- [ ] Implement basic biome selection logic
- [ ] Connect to terrain generation

### Phase 2: Biome Characteristics
- [ ] Define terrain parameters for each biome
- [ ] Implement vegetation placement by biome
- [ ] Add biome-specific block selection
- [ ] Create visual characteristics for each biome

### Phase 3: Biome Blending
- [ ] Implement boundary detection
- [ ] Add biome blending for terrain
- [ ] Add vegetation blending
- [ ] Refine visual transitions

## Technical Notes

### Performance Considerations
- Cache biome determinations at chunk level
- Use efficient noise algorithms
- Consider multi-threading for biome pre-calculation

### Visual Consistency
- Biome characteristics should be visually distinct yet harmonious
- Avoid harsh transitions in elevation
- Maintain consistent artistic style across biomes

## Testing Strategy

1. **Visual Inspection**: Check biome appearance and transitions
2. **Seed Testing**: Verify consistency across different seeds
3. **Performance Testing**: Measure impact on generation speed
4. **Edge Case Testing**: Check rare biome transitions

## Next Steps

1. Review existing documentation on desired biome types
2. Design BiomeType enumeration and BiomeData structure
3. Implement basic temperature and humidity generation
4. Create initial biome selection logic
5. Test with simple biome visualization
