# 08d.3a.3: Code Generation Infrastructure
*Created: 2025-06-08*
*Priority: HIGH - Core automation system*

## Status: ACTIVE ‚è≥
*Step 3 of Unified Block Resource System - Generate C++ and Python code from JSON data*

## Overview
Create automatic code generation from unified JSON block data to eliminate manual synchronization between texture generation (Python) and game logic (C++). This system will generate C++ enums, Python mappings, and ensure perfect data consistency across the entire engine.

## Key Design Decision: Block ID Management Strategy

### Current Problem: Hardcoded IDs in JSON
```json
{
  "AIR": {
    "id": 0,  // ‚Üê Hardcoded, maintenance burden
    "name": "Air",
    ...
  },
  "STONE": {
    "id": 1,  // ‚Üê Manual assignment, conflict-prone
    "name": "Stone",
    ...
  }
}
```

### Analysis: Should We Hardcode Block IDs?

#### ‚ùå Problems with Hardcoded IDs:
1. **Manual Maintenance**: Developer must manually assign unique IDs
2. **Conflict Potential**: Easy to accidentally duplicate IDs
3. **Insertion Difficulty**: Adding blocks in logical order requires renumbering
4. **Category Gaps**: Wastes ID space with artificial category boundaries
5. **Error-Prone**: Human error in ID assignment breaks the system

#### ‚úÖ Benefits of Auto-Generated IDs:
1. **Zero Conflicts**: Generation algorithm ensures uniqueness
2. **Insertion Safety**: New blocks get next available ID automatically
3. **Maintenance-Free**: No manual ID management required
4. **Optimal Packing**: No wasted ID space
5. **Category Flexibility**: Categories can grow/shrink as needed

#### üîí Critical Constraint: Save Game Compatibility
**Once an ID is assigned, it MUST remain stable forever**
- Save games store blocks by ID, not name
- Changing IDs breaks all existing save files
- ID assignments become permanent game data

### ‚úÖ SELECTED STRATEGY: Hybrid Auto-Generation with Stability

**Approach**: Auto-assign IDs based on declaration order with stability guarantees

```python
# Generation Algorithm:
def generate_block_ids(json_data):
    """
    Auto-assign IDs based on:
    1. Category order (terrain, fluids, processed, functional, advanced)
    2. Declaration order within each category file
    3. Existing ID registry for stability (id_registry.json)
    """
    
    # Step 1: Load existing ID assignments for stability
    existing_ids = load_id_registry()
    
    # Step 2: Assign IDs in deterministic order
    category_order = ["terrain", "fluids", "processed", "functional", "advanced", "placeholder"]
    next_id = 0
    
    for category in category_order:
        blocks = load_category_blocks(category)
        for block_name in blocks.keys():  # Preserves JSON declaration order
            if block_name in existing_ids:
                # Use existing ID for stability
                assigned_id = existing_ids[block_name]
            else:
                # Assign new ID
                assigned_id = next_id
                next_id += 1
            
            yield block_name, assigned_id
    
    # Step 3: Save updated registry for future stability
    save_id_registry(all_assignments)
```

**Registry File (id_registry.json)**:
```json
{
  "version": "1.0",
  "last_generated": "2025-06-08T12:00:00Z",
  "assignments": {
    "AIR": 0,
    "STONE": 1,
    "DIRT": 2,
    "GRASS": 3,
    // ... all block ID assignments
  },
  "next_available_id": 44,
  "notes": {
    "AIR": "Reserved ID 0 - special air block",
    "generation_order": "terrain ‚Üí fluids ‚Üí processed ‚Üí functional ‚Üí advanced ‚Üí placeholder"
  }
}
```

## Implementation Plan

### Phase 1: ID Generation System ‚è≥ CURRENT
- [ ] **1.1** Design ID assignment algorithm
  - [ ] **1.1.1** Create deterministic generation based on declaration order
  - [ ] **1.1.2** Implement category-based ordering system
  - [ ] **1.1.3** Add ID conflict detection and validation
  - [ ] **1.1.4** Test ID generation with current JSON data

- [ ] **1.2** Create ID registry system for stability
  - [ ] **1.2.1** Design id_registry.json format for storing assignments
  - [ ] **1.2.2** Implement registry loading and saving
  - [ ] **1.2.3** Add version tracking for compatibility
  - [ ] **1.2.4** Create registry validation and repair tools

- [ ] **1.3** Update JSON data to remove hardcoded IDs
  - [ ] **1.3.1** Generate initial ID registry from current JSON data
  - [ ] **1.3.2** Remove "id" fields from all block definitions
  - [ ] **1.3.3** Update JSON schema to make ID field optional
  - [ ] **1.3.4** Validate all JSON files parse correctly without IDs

### Phase 2: C++ Code Generation ‚è≥ PENDING
- [ ] **2.1** Create C++ header generator
  - [ ] **2.1.1** Design VoxelType enum generation from JSON + ID registry
  - [ ] **2.1.2** Generate BlockProperties struct definitions
  - [ ] **2.1.3** Create face pattern mapping generation
  - [ ] **2.1.4** Add header guards and includes management

- [ ] **2.2** Generate comprehensive C++ code
  - [ ] **2.2.1** Create voxel_types_generated.h with complete enum
  - [ ] **2.2.2** Generate block_properties_generated.cpp with all properties
  - [ ] **2.2.3** Create face_patterns_generated.h with pattern mappings
  - [ ] **2.2.4** Add compile-time validation for generated code

- [ ] **2.3** C++ integration helpers
  - [ ] **2.3.1** Generate string conversion functions (enum ‚Üî string)
  - [ ] **2.3.2** Create block property lookup tables
  - [ ] **2.3.3** Add runtime validation functions
  - [ ] **2.3.4** Generate debug/logging helper functions

### Phase 3: Python Code Generation ‚è≥ PENDING
- [ ] **3.1** Create Python mapping generator
  - [ ] **3.1.1** Generate BLOCK_MAPPING dictionary from JSON + ID registry
  - [ ] **3.1.2** Create texture generation parameter mappings
  - [ ] **3.1.3** Generate face pattern coordinate mappings
  - [ ] **3.1.4** Add Python validation and type hints

- [ ] **3.2** Generate texture system integration
  - [ ] **3.2.1** Create block_mapping_generated.py for atlas generation
  - [ ] **3.2.2** Generate texture coordinator mappings
  - [ ] **3.2.3** Create atlas slot assignment tables
  - [ ] **3.2.4** Add texture validation functions

- [ ] **3.3** Python tooling integration
  - [ ] **3.3.1** Generate debug and inspection tools
  - [ ] **3.3.2** Create block data query functions
  - [ ] **3.3.3** Add data export utilities
  - [ ] **3.3.4** Generate validation and testing helpers

### Phase 4: Build System Integration ‚è≥ PENDING
- [ ] **4.1** CMake integration
  - [ ] **4.1.1** Create custom CMake commands for code generation
  - [ ] **4.1.2** Add JSON data dependency tracking
  - [ ] **4.1.3** Integrate validation as pre-build step
  - [ ] **4.1.4** Add generated file cleanup and rebuild rules

- [ ] **4.2** Development workflow integration
  - [ ] **4.2.1** Create manual generation script for rapid iteration
  - [ ] **4.2.2** Add watch-mode for automatic regeneration during development
  - [ ] **4.2.3** Create diff tools to show generation changes
  - [ ] **4.2.4** Add generation status reporting and logging

- [ ] **4.3** Validation and safety
  - [ ] **4.3.1** Add pre-build JSON schema validation
  - [ ] **4.3.2** Create ID registry consistency checks
  - [ ] **4.3.3** Add generated code compilation testing
  - [ ] **4.3.4** Create rollback and recovery mechanisms

### Phase 5: Legacy System Migration ‚è≥ PENDING
- [ ] **5.1** Parallel system implementation
  - [ ] **5.1.1** Keep existing BLOCK_MAPPING working during transition
  - [ ] **5.1.2** Add feature flags to switch between old/new systems
  - [ ] **5.1.3** Create validation tools to compare old vs new output
  - [ ] **5.1.4** Add fallback mechanisms for safety

- [ ] **5.2** Gradual migration process
  - [ ] **5.2.1** Switch atlas generation to use generated mappings
  - [ ] **5.2.2** Update C++ engine to use generated enums and properties
  - [ ] **5.2.3** Migrate face pattern system to generated data
  - [ ] **5.2.4** Remove old hardcoded systems after validation

- [ ] **5.3** Compatibility verification
  - [ ] **5.3.1** Pixel-perfect atlas comparison (old vs new)
  - [ ] **5.3.2** Save game compatibility testing
  - [ ] **5.3.3** Performance benchmarking
  - [ ] **5.3.4** Feature parity validation across all systems

### Phase 6: Advanced Features ‚è≥ PENDING
- [ ] **6.1** Multi-target generation
  - [ ] **6.1.1** Add support for additional languages (Rust, C#, etc.)
  - [ ] **6.1.2** Create pluggable generator architecture
  - [ ] **6.1.3** Add custom template support
  - [ ] **6.1.4** Create language-specific optimization passes

- [ ] **6.2** Advanced validation
  - [ ] **6.2.1** Add semantic validation (texture references, dependencies)
  - [ ] **6.2.2** Create game logic validation (balance, progression)
  - [ ] **6.2.3** Add performance impact analysis
  - [ ] **6.2.4** Create automated testing for generated systems

### Phase 7: Workflow Documentation ‚è≥ PENDING
- [ ] **7.1** Create comprehensive workflow documentation
  - [ ] **7.1.1** Document new block addition workflow in main README.md
  - [ ] **7.1.2** Create detailed sub-README for block system workflow
  - [ ] **7.1.3** Add short workflow summary to CURRENT_TODO.md
  - [ ] **7.1.4** Document texture atlas regeneration triggers and timing

- [ ] **7.2** Developer workflow guides
  - [ ] **7.2.1** Create step-by-step guide for adding new blocks
  - [ ] **7.2.2** Document code generation trigger scenarios
  - [ ] **7.2.3** Create troubleshooting guide for generation failures
  - [ ] **7.2.4** Document manual vs automatic generation modes

## File Structure

### Core Generation Scripts
- `scripts/generate_block_code.py` - Main generation orchestrator
- `scripts/generators/cpp_generator.py` - C++ code generation
- `scripts/generators/python_generator.py` - Python code generation
- `scripts/generators/id_manager.py` - ID assignment and registry management

### Generated Files (Auto-created)
- `engine/include/world/voxel_types_generated.h` - Complete VoxelType enum
- `engine/src/world/block_properties_generated.cpp` - All block properties
- `engine/include/world/face_patterns_generated.h` - Face pattern mappings
- `block_mapping_generated.py` - BLOCK_MAPPING for atlas generation
- `data/id_registry.json` - Stable ID assignments

### Configuration
- `scripts/generation_config.json` - Generation settings and options
- `scripts/templates/` - Code generation templates
- `scripts/validators/` - Validation and testing utilities

## Success Criteria
- [ ] ‚úÖ Zero manual ID management required
- [ ] ‚úÖ Perfect synchronization between C++ and Python systems
- [ ] ‚úÖ Save game compatibility preserved during changes
- [ ] ‚úÖ Build system automatically regenerates on JSON changes
- [ ] ‚úÖ Generated code is human-readable and debuggable
- [ ] ‚úÖ Legacy system compatibility during transition
- [ ] ‚úÖ Performance equal or better than manual systems

## Related Files
- **Data Source**: `data/blocks/*.json` - Unified block definitions
- **Legacy Code**: `create_atlas.py` (BLOCK_MAPPING), `engine/include/world/voxel_types.h`
- **Main Task**: `08d.3a_unified_block_resource_system.md`
- **Implementation Notes**: `08d.3a_implementation_notes.md`

---

**Key Innovation**: Auto-generated IDs with stability registry eliminates manual maintenance while preserving save game compatibility forever.
