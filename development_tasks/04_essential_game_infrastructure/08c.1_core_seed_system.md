# Core Seed System
*Created: 2025-06-05 22:59*
*Last Updated: 2025-06-05 22:59*

## Overview
This document details the core seed system that will power Voxel Castle's world generation. The seed system provides deterministic, reproducible world generation by deriving all random values from a single initial seed.

## Design Goals

1. **Determinism**: Same seed always produces identical worlds
2. **Flexibility**: Support both numeric and string-based seeds
3. **Localized Variation**: Generate different terrain in different areas
4. **Extensibility**: Support future features (biomes, structures, etc.)
5. **Performance**: Fast seed-to-value conversion for real-time generation

## Core Components

### WorldSeed Class

**Purpose**: Central management of the world seed and derived values

**Key Functionality**:
- [ ] Store and manage the master world seed
- [ ] Convert string seeds to numeric values
- [ ] Generate consistent random values for any world coordinate
- [ ] Support separate seed domains for different generation aspects (terrain, structures, etc.)

### LocationSeed Generator

**Purpose**: Generate consistent, unique seeds for specific coordinates or regions

**Key Functionality**:
- [ ] Block-level seed generation (`getBlockSeed(x, y, z)`)
- [ ] Chunk-level seed generation (`getChunkSeed(chunkX, chunkZ)`)
- [ ] Region-level seed generation (`getRegionSeed(regionX, regionZ)`)
- [ ] Feature-specific seed generation (`getFeatureSeed(x, y, z, featureType)`)

### Noise Generation Integration

**Purpose**: Connect seed system to procedural noise generators

**Key Functionality**:
- [ ] Seed-based initialization of noise generators
- [ ] Multiple noise layers with different parameters
- [ ] Domain warping for natural-looking terrain
- [ ] Octave noise with seed-based parameters

## Implementation Details

### Seed Initialization

1. **User-Provided Seed**:
   - Numeric: Use directly as the master seed
   - String: Hash the string to produce a numeric seed
   - Empty/Random: Generate a random seed value

2. **Seed Transformation**:
   - Apply seed scrambling to avoid patterns with sequential seeds
   - Use prime number multiplication to improve distribution
   - Store the transformed seed as the master seed

### Coordinate-Based Seed Derivation

For generating unique seed values at each location:

```
// Pseudocode (not actual implementation)
uint64_t getBlockSeed(int64_t x, int64_t y, int64_t z) {
    // Combine position with master seed
    // Use bit operations and prime multiplication to distribute values
    // Return a unique but deterministic value for this position
}
```

### Feature-Specific Seeds

Different world features will use different "seed domains" to ensure independent randomization:

```
// Pseudocode (not actual implementation)
uint64_t getFeatureSeed(int64_t x, int64_t y, int64_t z, FeatureType type) {
    // Combine position with master seed and feature type
    // Each feature type gets a different random sequence
}
```

## Transition Strategy

### Phase 1: Basic Seed Implementation
- [ ] Create WorldSeed class with basic functionality
- [ ] Implement coordinate-based seed derivation
- [ ] Connect seed system to existing noise generators
- [ ] Support numeric, string, and random seeds
- [ ] Validate reproducibility with test worlds

### Phase 2: Extended Functionality
- [ ] Add feature-specific seed domains
- [ ] Implement region and chunk level seed generation
- [ ] Add biome seed generation
- [ ] Support structure placement seeding

### Phase 3: Integration
- [ ] Connect to world creation dialog
- [ ] Store seed in level.dat
- [ ] Add seed display in debug overlay

## Technical Notes

### Seed Uniqueness

To ensure different seeds produce significantly different worlds:
- Use high-quality bit mixing algorithms
- Apply avalanche effect principles
- Test with sequential seeds to confirm variation

### Performance Considerations

Seed derivation must be fast since it's used during chunk generation:
- Use bit operations rather than division/modulo
- Cache common values
- Minimize heap allocations

## Testing Strategy

1. **Reproducibility Testing**: Generate same world twice with same seed
2. **Variation Testing**: Verify different seeds produce different worlds
3. **Edge Case Testing**: Test boundary values, very large/small seeds
4. **Performance Testing**: Measure generation time with seed system

## Next Steps

1. Review current noise generation system
2. Design seed class structure
3. Implement basic seed-to-noise integration
4. Test with simple terrain generation
5. Extend to support all needed features
