# 08d.3: Unified Block Resource System
*Created: 2025-06-07 12:00*
*Last Updated: 2025-06-07 12:00*
*Priority: HIGH - Essential for scalable block system*

## Status: ACTIVE ⏳
*Consolidating texture generation and game logic data sources*

## Overview
Create a unified, centralized block resource system that serves as the single source of truth for both texture generation (Python) and game logic (C++). This system will dynamically manage atlas expansion and ensure perfect synchronization between visual and logical block properties.

## Key Problems to Solve

### 1. Data Source Fragmentation
- **Python**: Uses `BLOCK_MAPPING` dictionary in create_atlas.py
- **C++**: Uses separate `VoxelType` enum, `BlockProperties`, and `FacePattern` systems
- **Result**: Manual synchronization required, prone to inconsistencies

### 2. Static Atlas System
- **Current**: Fixed sizes (16x16 main, 3x3 side, 1x1 bottom)
- **Needed**: Dynamic expansion (main_2, side_2, bottom_2, etc.)
- **Impact**: Limited to current block count, no scalability

### 3. Manual Texture-Logic Mapping
- **Current**: Changes require updates in multiple files
- **Needed**: Single edit updates both texture generation and game logic

## Proposed Solution

### Phase 1: Centralized Block Database ⏳ CURRENT
Create a unified JSON/YAML data format that defines all block properties:

```json
{
  "blocks": {
    "STONE": {
      "id": 1,
      "name": "Stone",
      "face_pattern": "UNIFORM",
      "properties": {
        "solid": true,
        "transparent": false,
        "hardness": 1.5,
        "tool": "PICKAXE"
      },
      "texture": {
        "type": "stone",
        "subtype": "stone",
        "atlas_slots": {
          "main": 1
        }
      }
    },
    "GRASS": {
      "id": 3,
      "name": "Grass Block",
      "face_pattern": "ALL_DIFFERENT",
      "properties": {
        "solid": true,
        "transparent": false,
        "hardness": 0.6
      },
      "texture": {
        "type": "organic",
        "subtype": "grass",
        "atlas_slots": {
          "main": 3,    // top face
          "side": 1,    // side faces  
          "bottom": 1   // bottom face
        }
      }
    }
  }
}
```

### Phase 2: Dynamic Atlas Management ⏳ PENDING
Implement automatic atlas size detection and expansion:

```python
def determine_atlas_requirements(blocks_data):
    """Calculate required atlas sizes based on face patterns"""
    main_slots = []
    side_slots = []
    bottom_slots = []
    
    for block in blocks_data:
        if block.face_pattern in ["UNIFORM", "ALL_DIFFERENT", "TOP_BOTTOM_DIFFERENT"]:
            main_slots.append(block.id)
        if block.face_pattern in ["ALL_DIFFERENT", "TOP_BOTTOM_DIFFERENT"]:
            side_slots.append(block.id)
        if block.face_pattern == "ALL_DIFFERENT":
            bottom_slots.append(block.id)
    
    return {
        "main": calculate_atlas_count(len(main_slots)),    # main_1, main_2, etc.
        "side": calculate_atlas_count(len(side_slots)),    # side_1, side_2, etc.
        "bottom": calculate_atlas_count(len(bottom_slots)) # bottom_1, bottom_2, etc.
    }
```

### Phase 3: Code Generation ⏳ PENDING
Generate C++ enums and Python mappings from the unified data:

**Generated C++ (voxel_types_generated.h):**
```cpp
enum class VoxelType : uint8_t {
    AIR = 0,
    STONE = 1,
    DIRT = 2,
    GRASS = 3,
    // ... auto-generated from data
};
```

**Generated Python (block_mapping_generated.py):**
```python
BLOCK_MAPPING = {
    1: {'type': 'stone', 'subtype': 'stone'},
    3: {'type': 'organic', 'subtype': 'grass'},
    # ... auto-generated from data
}
```

## Implementation Plan

### Step 1: Create Unified Block Data Format ⏳ CURRENT
- [ ] Design JSON/YAML schema for block definitions
- [ ] Convert existing block data to unified format
- [ ] Validate data consistency across all 256 block types

### Step 2: Atlas Size Calculator ⏳ PENDING
- [ ] Implement dynamic atlas size calculation
- [ ] Add support for multiple atlas generation (main_2, side_2, etc.)
- [ ] Update existing atlas generation to use new system

### Step 3: Code Generation Tools ⏳ PENDING
- [ ] Create Python script to generate C++ headers from data
- [ ] Create Python script to generate texture mapping from data
- [ ] Integrate code generation into build process

### Step 4: Engine Integration ⏳ PENDING
- [ ] Update C++ texture loading to handle multiple atlases
- [ ] Update mesh generation to use dynamic atlas indexing
- [ ] Add runtime validation for atlas-data consistency

## Questions & Decisions Needed

### Data Format Choice
**Options:**
- **JSON**: Easy to parse, good tooling, human-readable
- **YAML**: More human-friendly, supports comments
- **Custom DSL**: Maximum flexibility, requires parser

**Recommendation**: JSON for simplicity and tool support

### Atlas Naming Convention
**Current**: `atlas_main_16x16.png`, `atlas_side_3x3.png`
**Proposed**: `atlas_main_1.png`, `atlas_main_2.png`, `atlas_side_1.png`, etc.

**Benefits**: Cleaner naming, size-agnostic

### Code Generation Integration
**Options:**
- **Build-time**: Generate during CMake/build process
- **Manual**: Run script when data changes
- **Runtime**: Load data at application start

**Recommendation**: Build-time generation for compile-time safety

## Success Criteria
- [ ] Single data source drives both texture generation and game logic
- [ ] Adding new blocks requires only one data file edit
- [ ] Atlas system automatically expands when needed
- [ ] Perfect synchronization between textures and properties
- [ ] Existing functionality preserved during transition

## Files to Create/Modify
- `data/blocks.json` (new unified data)
- `scripts/generate_block_code.py` (code generator)
- `create_atlas.py` (update for dynamic sizing)
- `engine/include/world/voxel_types.h` (make generated)
- `engine/src/world/block_properties.cpp` (use generated data)

## Related Tasks
- **08d.1**: ✅ Face-based atlas system (provides foundation)
- **08d.2**: ✅ Current atlas issues (resolved blocking issues)
- **08c**: World generation improvements (will benefit from unified system)

---

*This task consolidates texture generation and game logic into a single, maintainable system that scales automatically as we add more blocks.*
