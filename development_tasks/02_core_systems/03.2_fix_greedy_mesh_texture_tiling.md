# Task: Fix Greedy Mesh Texture Tiling

**Parent Task:** [03_build_mesh_generation_system.md](./03_build_mesh_generation_system.md)

**Date Logged:** 2025-05-14

---

## 1. Problem Description

When the greedy meshing algorithm merges multiple adjacent voxels of the same type into a single larger quad, the texture applied to this quad is stretched to fit its entire surface. This results in a distorted appearance, especially for larger merged faces.

**Current Incorrect Behavior:**
*   A 3x1 area of stone voxels will render with the stone texture stretched across the entire 3-voxel-long face.

**Desired Behavior:**
*   A 3x1 area of stone voxels should render with the stone texture tiled three times horizontally across the face. Each 1x1 section of the merged face should display one instance of the stone texture.
*   The tiling must respect the texture atlas, meaning only the specific portion of the atlas corresponding to the voxel's type should be tiled.

**Previous Incorrect Attempt:**
*   An earlier attempt to fix this resulted in the *entire texture atlas* being tiled across the merged face, rather than just the specific texture for the voxel type. This caused incorrect textures to appear (e.g., a stone surface showing parts of grass, dirt, etc., in a tiled fashion).

---

## 2. Analysis and Brainstorming

### Likely Cause
The UV coordinates for the vertices of a merged quad generated by the greedy meshing algorithm are likely being calculated as if the quad corresponds to a single instance of the texture. For example, UVs might range from `(atlas_tile_u0, atlas_tile_v0)` to `(atlas_tile_u1, atlas_tile_v1)` for the entire merged quad, regardless of how many voxel units it spans.

*   **Naive Meshing UVs:** Typically, for a single voxel face, UVs map directly to the corners of one texture tile within the atlas.
*   **Greedy Meshing UVs (Current Issue):** When faces are merged, if these "single tile" UVs are applied to the corners of the larger merged quad, the texture gets stretched.
*   **Greedy Meshing UVs (Desired):** To achieve tiling, the UV coordinates need to extend beyond the normalized `0..1` range (for a single tile) proportionally to the dimensions of the merged quad in voxel units. For a quad that is `W` voxels wide and `H` voxels high:
    *   Let `(u_start, v_start)` be the top-left UV coordinate of the specific texture tile in the atlas.
    *   Let `tile_norm_width` and `tile_norm_height` be the normalized width and height of one texture tile within the atlas (e.g., if atlas is 256px and tile is 16px, `tile_norm_width = 16.0/256.0`).
    *   The UVs for the merged quad should effectively span:
        *   U-range: `u_start` to `u_start + (W * tile_norm_width)`
        *   V-range: `v_start` to `v_start + (H * tile_norm_height)`
    *   OpenGL's `GL_REPEAT` texture wrapping mode will then handle the tiling correctly.

### Key Areas for Investigation:
1.  **UV Generation in `MeshBuilder::buildGreedyMesh`:** This is where the vertices and UVs for the merged quads are calculated. The logic needs to incorporate the width (`quad_width_voxels`) and height (`quad_height_voxels`) of the merged quad into the UV calculation.
2.  **Texture Atlas System (`TextureAtlas` class):**
    *   How are the base UV coordinates for a specific voxel type and face retrieved?
    *   Does it provide the normalized dimensions of a single tile within the atlas? This is crucial for calculating the tiled UVs.
3.  **OpenGL Texture Parameters:**
    *   Ensure that `GL_TEXTURE_WRAP_S` and `GL_TEXTURE_WRAP_T` are set to `GL_REPEAT` for the texture atlas when it's bound. If they are set to `GL_CLAMP_TO_EDGE` or similar, tiling will not occur.

---

## 3. Task List

### 3.1. Investigation & Preparation
- [ ] **3.1.1. Review `TextureAtlas` Implementation:**
    - [ ] Verify how to get base UV coordinates (e.g., top-left `(u,v)`) for a given voxel type/face.
    - [ ] Verify how to get the normalized width and height of a single texture tile within the atlas (e.g., `tile_normalized_width = tile_pixel_width / atlas_pixel_width`).
    - [ ] If necessary, add methods to `TextureAtlas` to easily retrieve these values.
- [ ] **3.1.2. Review OpenGL Texture Setup:**
    - [ ] Locate the code where the voxel texture atlas is loaded and its OpenGL parameters are set.
    - [ ] Confirm or ensure that `glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);` and `glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);` are being called for the atlas texture.

### 3.2. Modify UV Generation in Greedy Meshing
- [ ] **3.2.1. Locate UV assignment in `MeshBuilder::buildGreedyMesh` (or the relevant function that adds faces/quads for the greedy mesher).**
- [ ] **3.2.2. Identify where the dimensions (width `W`, height `H` in voxel units) of the current merged quad are known.**
- [ ] **3.2.3. Adjust UV Calculation:**
    - For each vertex of the merged quad, calculate its UV coordinates based on:
        - The base UVs of the texture tile from the atlas (`atlas_uv_top_left`, `atlas_uv_bottom_right` or similar).
        - The dimensions of the merged quad (`quad_voxel_width`, `quad_voxel_height`).
        - The orientation of the face and the quad.
    - **Example for a quad vertex (conceptual):**
      ```cpp
      // Assuming:
      // atlas_tile_u0, atlas_tile_v0 = top-left UV of the tile in the atlas
      // atlas_tile_u_span, atlas_tile_v_span = normalized width/height of one tile in the atlas
      // quad_width_voxels, quad_height_voxels = dimensions of the merged quad in voxel units

      // For the vertex at the "start" corner of the quad (e.g., top-left on a front face)
      vertex.u = atlas_tile_u0;
      vertex.v = atlas_tile_v0;

      // For the vertex at the "end" of the width extent (e.g., top-right on a front face)
      vertex.u = atlas_tile_u0 + (quad_width_voxels * atlas_tile_u_span);
      vertex.v = atlas_tile_v0;

      // For the vertex at the "end" of the height extent (e.g., bottom-left on a front face)
      vertex.u = atlas_tile_u0;
      vertex.v = atlas_tile_v0 + (quad_height_voxels * atlas_tile_v_span);

      // For the vertex at the "far" corner (e.g., bottom-right on a front face)
      vertex.u = atlas_tile_u0 + (quad_width_voxels * atlas_tile_u_span);
      vertex.v = atlas_tile_v0 + (quad_height_voxels * atlas_tile_v_span);
      ```
    - Ensure the UVs are assigned to the correct vertices of the quad based on its orientation (front, back, top, bottom, left, right face). The `addFace` method in `MeshBuilder` is a likely place where this logic will be concentrated or called from.

### 3.3. Testing and Verification
- [ ] **3.3.1. Create Specific Test Scenarios:**
    - [ ] A 3x1x1 strip of stone voxels.
    - [ ] A 1x3x1 strip of stone voxels.
    - [ ] A 3x3x1 flat plane of stone voxels.
    - [ ] A 5x2x1 flat plane of stone voxels.
    - [ ] A large cube (e.g., 4x4x4) of a single voxel type.
    - [ ] Adjacent areas of different voxel types to ensure tiling is per-type and doesn't bleed.
- [ ] **3.3.2. Visual Inspection:**
    - [ ] Run the game and observe the test scenarios.
    - [ ] Confirm that textures are tiled correctly (repeating, not stretched) on all faces of merged quads.
    - [ ] Confirm that the correct texture from the atlas is used for each voxel type.
    - [ ] Confirm that there are no visual artifacts like seams, incorrect scaling, or atlas bleeding.
- [ ] **3.3.3. Check Naive Meshing (Regression Test):**
    - [ ] If possible, switch to naive meshing for a simple object and ensure its textures are still correct (should be unaffected by these changes, but good to check).
- [ ] **3.3.4. Test with Different Texture Atlas Configurations (if applicable):**
    - [ ] If the atlas layout or tile sizes can change, ensure the solution is robust.

### 3.4. Documentation
- [ ] **3.4.1. Update comments in the code where UV generation is modified, explaining the tiling logic.**
- [ ] **3.4.2. Update this task file with any findings or changes to the plan.**
- [ ] **3.4.3. Mark this task as complete in `03_build_mesh_generation_system.md` once verified.**

---
**Status:** Open
