# Task: Build Mesh Generation System

**High-Level Goal:** Implement a system to convert voxel data from `ChunkSegment`s into renderable triangle meshes.

**Parent Task:** [2. Implement Core Systems (C++)](/home/system-x1/Projects/Voxel Castle/CURRENT_TODO.md#2-implement-core-systems-c)

**Design Document Reference:**
*   Consult `/home/system-x1/Projects/Voxel Castle/docs/design_specifications/Voxel Fortress Tech Stack (C++ Custom Engine Approach).md` for any relevant architectural guidelines.

---

## Sub-Tasks:

### 1. Basic Mesh Generation from Voxel Data
    - [x] 1.1. Define `VoxelMesh` (or similar) data structure to hold vertex attributes (position, normal, UVs) and indices.
    - [x] 1.2. Implement a function/method within `ChunkSegment` (or a dedicated `MeshBuilder` class) that iterates through its voxels.
    - [x] 1.3. For each solid voxel, generate faces (quads, then triangulate) for exposed sides (sides not adjacent to another solid voxel).
        - [x] 1.3.1. Start with a simple "naive" or "blocky" meshing approach where each voxel face is distinct.
        - [x] 1.3.2. Ensure correct vertex winding order for faces (e.g., counter-clockwise for front-facing).
        - [x] 1.3.3. Calculate basic face normals.
    - [x] 1.4. Store the generated mesh data.
    - [x] 1.5. **Testing:**
        - [x] 1.5.1. Create a test `ChunkSegment` with a simple pattern of voxels.
        - [x] 1.5.2. Generate the mesh.
        - [x] 1.5.3. (Placeholder for rendering) Log the number of vertices/triangles generated or visualize if a simple rendering path is available. For now, focus on data correctness.

### 2. Mesh Optimization (e.g., Greedy Meshing)
    - [x] 2.1. Research and select a suitable mesh optimization algorithm (Greedy Meshing is a common choice for voxel engines).
        - [x] 2.1.1. Understand the principles of Greedy Meshing: merging adjacent coplanar faces of the same voxel type.
    - [x] 2.2. Implement the chosen optimization algorithm (Greedy Meshing).
        - [x] 2.2.1. Iterate through the chunk in 3 dimensions (X, Y, Z). For each dimension, process 2D slices for both positive and negative face directions.
        - [x] 2.2.2. For each slice and direction:
            - [x] 2.2.2.1. Create a 2D mask (e.g., `std::vector<bool>` or `std::vector<std::vector<bool>>`) to keep track of voxels on the current slice whose faces have already been incorporated into a mesh quad. Initialize all to `false`.
            - [x] 2.2.2.2. Iterate through the primary axis of the slice (e.g., 'u' coordinate).
            - [x] 2.2.2.3. Iterate through the secondary axis of the slice (e.g., 'v' coordinate).
            - [x] 2.2.2.4. If the current voxel `(u, v)` on the slice is solid, its face in the current processing direction is exposed (i.e., adjacent voxel in that direction is air or outside chunk boundary), and it has not been masked (`mask[u][v] == false`):
                - [x] 2.2.2.4.1. Determine the `voxel_type` of the current voxel.
                - [x] 2.2.2.4.2. Greedily expand in the secondary axis ('v' direction) to find the `height` of the quad: Iterate while the voxel at `(u, v + height)` is of the same `voxel_type`, solid, its face is exposed, and it's not masked.
                - [x] 2.2.2.4.3. Greedily expand in the primary axis ('u' direction) to find the `width` of the quad: Iterate while all voxels from `(u + width, v)` to `(u + width, v + height - 1)` are of the same `voxel_type`, solid, their faces are exposed, and they are not masked.
                - [x] 2.2.2.4.4. Add the vertices and indices for the generated quad of `(width, height)` to the `VoxelMesh`. Ensure correct vertex winding and normal calculation.
                - [x] 2.2.2.4.5. Mark all voxels covered by this new quad in the 2D mask as `true`.
    - [x] 2.3. Update the mesh generation process to use the optimization. (This means `MeshBuilder` will have a `buildGreedyMesh` method).
    - [x] 2.4. **Testing:**
    - [x] 2.4.1. Create a test `ChunkSegment` with a variety of voxel configurations (e.g., solid blocks, flat planes, hollow shapes, single voxels, mixed types). // In progress, tests set up in main.cpp
    - [x] 2.4.2. Call `buildGreedyMesh` on the test chunk. // Done, issues found.
    - [x] 2.4.3. Compare the number of vertices/indices generated by `buildGreedyMesh` vs. `buildNaiveMesh` for the same chunk. Expect significantly fewer for `buildGreedyMesh`. // Comparison shows significant discrepancies, greedy mesh is too small.
    - [x] 2.4.4. (Visual) If rendering is available, render the mesh to visually inspect for correctness:
        - [x] No missing faces.
        - [x] No z-fighting or overlapping internal faces.
        - [x] Correct face culling (quads are facing outwards).
        - [x] Quads are maximal (greedy algorithm is working correctly).
    - [x] 2.4.5. Test with edge cases:
        - [x] Empty chunk.
        - [x] Fully solid chunk.
        - [x] Chunk with voxels only along edges or corners.
        - [x] Chunk with different voxel types adjacent to each other.

### 3. Texture Mapping Support
    - [x] 3.1. Define how voxel types map to texture coordinates (e.g., which part of a texture atlas corresponds to a stone voxel, grass voxel, etc.).
    - [x] 3.2. Modify the mesh generation to include UV coordinates for each vertex.
        - [x] 3.2.1. For naive meshing: Assign UVs based on the voxel face.
        - [x] 3.2.2. For optimized meshing: Ensure UVs correctly map to the larger merged quads.
    - [x] 3.3. **Testing:**
        - [x] 3.3.1. (Placeholder for rendering) Verify UVs by applying a test texture/atlas.

### 4. Texture Atlas System
    - [x] 4.1. Design a system for managing texture atlases.
        - [x] 4.1.1. Define how individual voxel textures are packed into a larger atlas image.
        - [x] 4.1.2. Create a mechanism to look up UV coordinates within the atlas for a given voxel type and face.
    - [x] 4.2. Implement loading and management of the texture atlas.
    - [x] 4.3. Integrate the texture atlas lookup into the UV generation step (Task 3.2).
    - [x] 4.4. **Testing:**
        - [x] 4.4.1. (Placeholder for rendering) Test with a sample texture atlas and verify correct texture application on generated meshes.
    - [ ] 4.4. Create a sample texture atlas image (`atlas.png`)
        - [ ] 4.4.1. Generate procedural textures for the atlas (e.g., stone, dirt, grass, wood, leaves, water, sand)
        - [ ] 4.4.2. Test with a sample texture atlas and verify correct texture application on voxels.

### 5. Integration and Refinement
    - [ ] 5.1. Integrate the mesh generation system with the `WorldManager` or `ChunkColumn` to trigger mesh updates when chunks change.
    - [ ] 5.2. Consider asynchronous mesh generation to avoid stalling the main thread.
    - [ ] 5.3. Profile and optimize mesh generation performance.
    - [ ] 5.4. Add Doxygen-style comments to new classes and functions.
    - [ ] 5.5. Update relevant design documents.

---
**Notes & Considerations:**
*   Start with the simplest approach that works (naive meshing) and iterate.
*   Rendering is not part of this task, but the generated mesh data should be suitable for a typical rendering pipeline (e.g., OpenGL).
*   Keep performance in mind, especially for large numbers of chunks.
*   Consider how different voxel types will affect meshing (e.g., transparent vs. opaque). This might be a later refinement.
*   Edge cases: chunk boundaries, transitions between different voxel types.

---
**Status:** In Progress
