# Task: Build Mesh Generation System

**High-Level Goal:** Implement a system to convert voxel data from `ChunkSegment`s into renderable triangle meshes.

**Parent Task:** [2. Implement Core Systems (C++)](/home/system-x1/Projects/Voxel Castle/CURRENT_TODO.md#2-implement-core-systems-c)

**Design Document Reference:**
*   Consult `/home/system-x1/Projects/Voxel Castle/docs/design_specifications/Voxel Fortress Tech Stack (C++ Custom Engine Approach).md` for any relevant architectural guidelines.

---

## Sub-Tasks:

### 1. Basic Mesh Generation from Voxel Data
    - [x] 1.1. Define `VoxelMesh` (or similar) data structure to hold vertex attributes (position, normal, UVs) and indices.
    - [x] 1.2. Implement a function/method within `ChunkSegment` (or a dedicated `MeshBuilder` class) that iterates through its voxels.
    - [x] 1.3. For each solid voxel, generate faces (quads, then triangulate) for exposed sides (sides not adjacent to another solid voxel).
        - [x] 1.3.1. Start with a simple "naive" or "blocky" meshing approach where each voxel face is distinct.
        - [x] 1.3.2. Ensure correct vertex winding order for faces (e.g., counter-clockwise for front-facing).
        - [x] 1.3.3. Calculate basic face normals.
    - [x] 1.4. Store the generated mesh data.
    - [x] 1.5. **Testing:**
        - [x] 1.5.1. Create a test `ChunkSegment` with a simple pattern of voxels.
        - [x] 1.5.2. Generate the mesh.
        - [x] 1.5.3. (Placeholder for rendering) Log the number of vertices/triangles generated or visualize if a simple rendering path is available. For now, focus on data correctness.

### 2. Mesh Optimization (e.g., Greedy Meshing)
    - [x] 2.1. Research and select a suitable mesh optimization algorithm (Greedy Meshing is a common choice for voxel engines).
        - [x] 2.1.1. Understand the principles of Greedy Meshing: merging adjacent coplanar faces of the same voxel type.
    - [x] 2.2. Implement the chosen optimization algorithm (Greedy Meshing).
        - [x] 2.2.1. Iterate through the chunk in 3 dimensions (X, Y, Z). For each dimension, process 2D slices for both positive and negative face directions.
        - [x] 2.2.2. For each slice and direction:
            - [x] 2.2.2.1. Create a 2D mask (e.g., `std::vector<bool>` or `std::vector<std::vector<bool>>`) to keep track of voxels on the current slice whose faces have already been incorporated into a mesh quad. Initialize all to `false`.
            - [x] 2.2.2.2. Iterate through the primary axis of the slice (e.g., 'u' coordinate).
            - [x] 2.2.2.3. Iterate through the secondary axis of the slice (e.g., 'v' coordinate).
            - [x] 2.2.2.4. If the current voxel `(u, v)` on the slice is solid, its face in the current processing direction is exposed (i.e., adjacent voxel in that direction is air or outside chunk boundary), and it has not been masked (`mask[u][v] == false`):
                - [x] 2.2.2.4.1. Determine the `voxel_type` of the current voxel.
                - [x] 2.2.2.4.2. Greedily expand in the secondary axis ('v' direction) to find the `height` of the quad: Iterate while the voxel at `(u, v + height)` is of the same `voxel_type`, solid, its face is exposed, and it's not masked.
                - [x] 2.2.2.4.3. Greedily expand in the primary axis ('u' direction) to find the `width` of the quad: Iterate while all voxels from `(u + width, v)` to `(u + width, v + height - 1)` are of the same `voxel_type`, solid, their faces are exposed, and they are not masked.
                - [x] 2.2.2.4.4. Add the vertices and indices for the generated quad of `(width, height)` to the `VoxelMesh`. Ensure correct vertex winding and normal calculation.
                - [x] 2.2.2.4.5. Mark all voxels covered by this new quad in the 2D mask as `true`.
    - [x] 2.3. Update the mesh generation process to use the optimization. (This means `MeshBuilder` will have a `buildGreedyMesh` method).
    - [x] 2.4. **Testing:**
    - [x] 2.4.1. Create a test `ChunkSegment` with a variety of voxel configurations (e.g., solid blocks, flat planes, hollow shapes, single voxels, mixed types). // In progress, tests set up in main.cpp
    - [x] 2.4.2. Call `buildGreedyMesh` on the test chunk. // Done, issues found.
    - [x] 2.4.3. Compare the number of vertices/indices generated by `buildGreedyMesh` vs. `buildNaiveMesh` for the same chunk. Expect significantly fewer for `buildGreedyMesh`. // Comparison shows significant discrepancies, greedy mesh is too small.
    - [x] 2.4.4. (Visual) If rendering is available, render the mesh to visually inspect for correctness:
        - [x] No missing faces.
        - [x] No z-fighting or overlapping internal faces.
        - [x] Correct face culling (quads are facing outwards).
        - [x] Quads are maximal (greedy algorithm is working correctly).
    - [x] 2.4.5. Test with edge cases:
        - [x] Empty chunk.
        - [x] Fully solid chunk.
        - [x] Chunk with voxels only along edges or corners.
        - [x] Chunk with different voxel types adjacent to each other.

### 3. Texture Mapping Support
    - [x] 3.1. Define how voxel types map to texture coordinates (e.g., which part of a texture atlas corresponds to a stone voxel, grass voxel, etc.).
    - [x] 3.2. Modify the mesh generation to include UV coordinates for each vertex.
        - [x] 3.2.1. For naive meshing: Assign UVs based on the voxel face.
        - [x] 3.2.2. For optimized meshing: Ensure UVs correctly map to the larger merged quads.
    - [x] 3.3. **Testing:**
        - [x] 3.3.1. (Placeholder for rendering) Verify UVs by applying a test texture/atlas.

### 4. Texture Atlas System
    - [x] 4.1. Design a system for managing texture atlases.
        - [x] 4.1.1. Define how individual voxel textures are packed into a larger atlas image.
        - [x] 4.1.2. Create a mechanism to look up UV coordinates within the atlas for a given voxel type and face.
    - [x] 4.2. Implement loading and management of the texture atlas.
    - [x] 4.3. Integrate the texture atlas lookup into the UV generation step (Task 3.2).
    - [x] 4.4. **Testing:** // User happy with current atlas.png, procedural generation deferred.
        - [x] 4.4.1. Generate procedural textures for the atlas (e.g., stone, dirt, grass, wood, leaves, water, sand) // Deferred - current atlas.png is sufficient for now.
        - [x] 4.4.2. Test with a sample texture atlas and verify correct texture application on voxels. // Completed as part of texture debugging.

### 5. Integration and Refinement
    - [x] 5.1. Integrate the mesh generation system with the `WorldManager` or `ChunkColumn` to trigger mesh updates when chunks change.
        - **Goal:** Shift mesh generation and update responsibility from manual calls in `main.cpp` to the `WorldManager`.
        - **Architectural Changes (Summary - details in sub-sub-tasks):**
            - `ChunkSegment` manages its own `VoxelMesh` and dirty flag.
            - `ChunkSegment` has `rebuildMesh()` method.
            - `WorldManager` handles `ChunkSegment` creation, initial meshing, calling `rebuildMesh()` on dirty segments, and providing meshes for rendering.
        - **Dynamic Update Testing Strategy (Option B - Implemented through sub-sub-tasks):**
            - Initial state: `WorldManager` creates and meshes a `ChunkSegment`; mesh is rendered.
            - Delayed Trigger: Modify a voxel via `WorldManager::setVoxelAt()`, marking segment dirty.
            - Verification: `WorldManager` update rebuilds mesh; render shows change.
        - **Sub-Sub-Tasks for 5.1:**
            - [x] **5.1.1. `ChunkSegment`: Add `voxelMesh` member (`std::unique_ptr<VoxelEngine::Rendering::VoxelMesh>`) and `isMeshDirty` flag (`bool`).**
            - [x] **5.1.2. `ChunkSegment`: Implement `rebuildMesh(TextureAtlas& atlas, MeshBuilder& meshBuilder)` method. (Note: Existing implementation already builds mesh and clears dirty flag, exceeding initial stub requirement).**
            - [x] **5.1.3. `WorldManager`: Enhance to create `ChunkSegment`s and ensure initial mesh generation is triggered.**
                - Action: Ensure `WorldManager` (via `ChunkColumn`) creates `ChunkSegment` instances and populates them with initial voxel data.
                - Action: Ensure that newly created and populated `ChunkSegment`s are marked as dirty, so that their mesh will be built during the next `updateDirtyMeshes` call.
            - [x] **5.1.4. Rendering Loop: Fetch and render meshes from `WorldManager`.**
                - [x] Action: `WorldManager`: Add method like `std::vector<const VoxelMesh*> getSegmentMeshesToRender() const;` (Covered by existing `getAllSegmentMeshes()`)
                - [x] Action: `main.cpp`: Remove old dummy mesh rendering. (User confirms current rendering in `main.cpp` uses `WorldManager` and is the intended path. No other world mesh rendering paths exist.)
                - [x] Action: `main.cpp`: In render loop, call `worldManager.getAllSegmentMeshes()` and render the returned meshes. (User confirms this is already implemented.)
                - **Note:** The current "dummy" checkerboard content generated by `WorldManager` for the world is expected at this stage. Actual world generation logic will replace this later.
            - [x] **5.1.5. `WorldManager`: Implement `setVoxel(world_x, world_y, world_z, voxel_type)` and mark segment dirty.** (Existing `WorldManager::setVoxel` overloads and `ChunkSegment::setVoxel` fulfill this.)
                - [x] Action: Create `void setVoxel(int world_x, int world_y, int world_z, VoxelType voxel_type);` in `WorldManager`. (Exists)
                - [x] Action: Implementation: Convert world coordinates to segment/local coordinates, modify the segment's voxel data, and set `isMeshDirty = true;` for that segment. (Implemented via `ChunkColumn::setVoxel` and `ChunkSegment::setVoxel`)
            - [x] **5.1.6. `WorldManager`: Implement update logic to rebuild dirty meshes.** (Existing `WorldManager::updateDirtyMeshes` called from `main.cpp` fulfills this.)
                - [x] Action: In `WorldManager`'s main update method (called every frame): Iterate through managed `ChunkSegment`s. If a segment's `isMeshDirty` is `true`, call its `rebuildMesh()` method. (Implemented as `WorldManager::updateDirtyMeshes`)
            - [ ] **5.1.7. Testing: Verify dynamic mesh updates.**
                - Action: Initial state: `WorldManager` creates and meshes a segment with a test pattern; mesh is rendered.
                - Action: Trigger: After a delay or key press, call `WorldManager::setVoxel()` to modify a voxel.
                - Action: Verification: `WorldManager`'s update logic detects the dirty segment, triggers rebuild. The subsequent render displays the updated mesh.
    - [ ] 5.2. Consider asynchronous mesh generation to avoid stalling the main thread.
    - [ ] 5.3. Profile and optimize mesh generation performance.
    - [ ] 5.4. Add Doxygen-style comments to new classes and functions.
    - [ ] 5.5. Update relevant design documents.

---
**Notes & Considerations:**
*   Start with the simplest approach that works (naive meshing) and iterate.
*   Rendering is not part of this task, but the generated mesh data should be suitable for a typical rendering pipeline (e.g., OpenGL).
*   Keep performance in mind, especially for large numbers of chunks.
*   Consider how different voxel types will affect meshing (e.g., transparent vs. opaque). This might be a later refinement.
*   Edge cases: chunk boundaries, transitions between different voxel types.

---
**Status:** In Progress
