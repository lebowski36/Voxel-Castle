#!/usr/bin/env python3
"""
C++ Code Generator for Voxel Block System

Generates C++ headers from JSON block definitions and ID registry.
Creates type-safe enums, lookup tables, and utility functions.
"""

import json
import os
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Any

class CppGenerator:
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.id_registry_path = self.project_root / "data" / "id_registry.json"
        self.blocks_dir = self.project_root / "data" / "blocks"
        self.output_dir = self.project_root / "engine" / "include" / "generated"
        
    def load_data(self):
        """Load ID registry and block definitions"""
        print("Loading data files...")
        
        # Load ID registry
        with open(self.id_registry_path, 'r') as f:
            self.id_registry = json.load(f)
        
        # Load all block definition files
        self.block_definitions = {}
        block_files = [
            "terrain.json",
            "fluids.json", 
            "processed.json",
            "functional.json",
            "advanced.json",
            "placeholder.json"
        ]
        
        for file_name in block_files:
            file_path = self.blocks_dir / file_name
            if file_path.exists():
                with open(file_path, 'r') as f:
                    data = json.load(f)
                    if isinstance(data, dict) and "blocks" in data:
                        category = file_name.replace(".json", "")
                        self.block_definitions[category] = data["blocks"]
                        print(f"  Loaded {len(data['blocks'])} blocks from {file_name}")
        
        # Build categorized mapping from block definitions and ID registry
        self.categorized_blocks = {}
        for category, blocks in self.block_definitions.items():
            self.categorized_blocks[category] = {}
            for block_key in blocks.keys():
                if block_key in self.id_registry["assignments"]:
                    self.categorized_blocks[category][block_key] = self.id_registry["assignments"][block_key]
                else:
                    print(f"Warning: Block {block_key} not found in ID registry")
        
        print(f"  Built categorized mapping with {len(self.id_registry['assignments'])} total blocks")
    
    def generate_header_guard(self, filename: str) -> str:
        """Generate header guard macro"""
        guard = filename.upper().replace(".", "_").replace("/", "_")
        return f"GENERATED_{guard}_H"
    
    def generate_file_header(self, description: str) -> str:
        """Generate standard file header with timestamp and warning"""
        timestamp = datetime.now().isoformat()
        return f"""/*
 * {description}
 * 
 * AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
 * Generated on: {timestamp}
 * Source: JSON block definitions + ID registry
 * 
 * This file is automatically generated by scripts/generators/cpp_generator.py
 * To update this file, modify the JSON data files and run the generator.
 */

"""
    
    def format_enum_name(self, block_key: str) -> str:
        """Convert block key to C++ enum name"""
        return block_key.upper()
    
    def format_constant_name(self, block_key: str) -> str:
        """Convert block key to C++ constant name"""
        return f"BLOCK_{block_key.upper()}"
    
    def generate_voxel_types_header(self) -> str:
        """Generate the main voxel types header"""
        header_guard = self.generate_header_guard("voxel_types_generated.h")
        content = self.generate_file_header("Voxel Block Type Definitions")
        
        content += f"""#ifndef {header_guard}
#define {header_guard}

#include <cstdint>
#include <string>
#include <unordered_map>
#include <vector>

namespace VoxelEngine {{

// Forward declarations
struct BlockProperties;

"""
        
        # Generate VoxelType enum
        content += "// Voxel block type enumeration\n"
        content += "enum class VoxelType : uint16_t {\n"
        
        # Add enum values from categorized blocks
        for category_name, blocks in self.categorized_blocks.items():
            content += f"    // {category_name.upper()} BLOCKS\n"
            for block_key, block_id in blocks.items():
                enum_name = self.format_enum_name(block_key)
                content += f"    {enum_name} = {block_id},\n"
            content += "\n"
        
        content += f"    // Utility values\n"
        content += f"    COUNT = {self.id_registry['next_available_id']},\n"
        content += f"    INVALID = 65535\n"
        content += "};\n\n"
        
        # Generate type constants for convenience
        content += "// Block type constants for easier usage\n"
        content += "namespace BlockTypes {\n"
        for category_name, blocks in self.categorized_blocks.items():
            content += f"    // {category_name.upper()}\n"
            for block_key, block_id in blocks.items():
                const_name = self.format_constant_name(block_key)
                enum_name = self.format_enum_name(block_key)
                content += f"    constexpr VoxelType {const_name} = VoxelType::{enum_name};\n"
            content += "\n"
        content += "}\n\n"
        
        # Generate utility functions
        content += """// Utility functions
const char* voxelTypeToString(VoxelType type);
VoxelType stringToVoxelType(const std::string& name);
bool isValidVoxelType(VoxelType type);
bool isValidVoxelTypeId(uint16_t id);

// Type conversion helpers
inline uint16_t toVoxelId(VoxelType type) {
    return static_cast<uint16_t>(type);
}

inline VoxelType fromVoxelId(uint16_t id) {
    return static_cast<VoxelType>(id);
}

// Category checking functions
bool isTerrain(VoxelType type);
bool isFluid(VoxelType type);
bool isProcessed(VoxelType type);
bool isFunctional(VoxelType type);
bool isAdvanced(VoxelType type);
bool isPlaceholder(VoxelType type);

} // namespace VoxelEngine

"""
        
        content += f"#endif // {header_guard}\n"
        return content
    
    def generate_voxel_types_source(self) -> str:
        """Generate the implementation file for voxel types"""
        content = self.generate_file_header("Voxel Block Type Implementation")
        
        content += """#include "generated/voxel_types_generated.h"
#include <unordered_map>
#include <string>

namespace VoxelEngine {

// String name lookup table
static const std::unordered_map<VoxelType, const char*> voxelTypeNames = {
"""
        
        # Generate name lookup table
        for category_name, blocks in self.categorized_blocks.items():
            content += f"    // {category_name.upper()}\n"
            for block_key, block_id in blocks.items():
                enum_name = self.format_enum_name(block_key)
                content += f"    {{VoxelType::{enum_name}, \"{block_key}\"}},\n"
            content += "\n"
        
        content += "};\n\n"
        
        # Generate reverse lookup table
        content += "static const std::unordered_map<std::string, VoxelType> voxelTypesByName = {\n"
        for category_name, blocks in self.categorized_blocks.items():
            content += f"    // {category_name.upper()}\n"
            for block_key, block_id in blocks.items():
                enum_name = self.format_enum_name(block_key)
                content += f"    {{\"{block_key}\", VoxelType::{enum_name}}},\n"
            content += "\n"
        
        content += "};\n\n"
        
        # Generate utility function implementations
        content += """const char* voxelTypeToString(VoxelType type) {
    auto it = voxelTypeNames.find(type);
    return (it != voxelTypeNames.end()) ? it->second : "UNKNOWN";
}

VoxelType stringToVoxelType(const std::string& name) {
    auto it = voxelTypesByName.find(name);
    return (it != voxelTypesByName.end()) ? it->second : VoxelType::INVALID;
}

bool isValidVoxelType(VoxelType type) {
    return voxelTypeNames.find(type) != voxelTypeNames.end();
}

bool isValidVoxelTypeId(uint16_t id) {
    return isValidVoxelType(static_cast<VoxelType>(id));
}

"""
        
        # Generate category checking functions
        def generate_category_check(category_name: str, blocks: Dict[str, int]) -> str:
            func_name = f"is{category_name.capitalize()}"
            func_content = f"bool {func_name}(VoxelType type) {{\n"
            func_content += "    switch (type) {\n"
            for block_key in blocks.keys():
                enum_name = self.format_enum_name(block_key)
                func_content += f"        case VoxelType::{enum_name}:\n"
            func_content += "            return true;\n"
            func_content += "        default:\n"
            func_content += "            return false;\n"
            func_content += "    }\n"
            func_content += "}\n\n"
            return func_content
        
        for category_name, blocks in self.categorized_blocks.items():
            content += generate_category_check(category_name, blocks)
        
        content += "} // namespace VoxelEngine\n"
        return content
    
    def generate_all(self):
        """Generate all C++ files"""
        print("=== C++ Code Generation ===")
        
        # Ensure output directory exists
        self.output_dir.mkdir(parents=True, exist_ok=True)
        
        # Load data
        self.load_data()
        
        # Generate header file
        print("Generating voxel_types_generated.h...")
        header_content = self.generate_voxel_types_header()
        header_path = self.output_dir / "voxel_types_generated.h"
        with open(header_path, 'w') as f:
            f.write(header_content)
        print(f"  Written: {header_path}")
        
        # Generate source file
        print("Generating voxel_types_generated.cpp...")
        source_content = self.generate_voxel_types_source()
        source_path = self.project_root / "engine" / "src" / "generated"
        source_path.mkdir(parents=True, exist_ok=True)
        source_file = source_path / "voxel_types_generated.cpp"
        with open(source_file, 'w') as f:
            f.write(source_content)
        print(f"  Written: {source_file}")
        
        print("✅ C++ code generation complete!")
        return True

def main():
    """Main entry point"""
    import sys
    
    # Get project root (assume script is in scripts/generators/)
    script_dir = Path(__file__).parent
    project_root = script_dir.parent.parent
    
    generator = CppGenerator(str(project_root))
    
    try:
        success = generator.generate_all()
        sys.exit(0 if success else 1)
    except Exception as e:
        print(f"❌ Error during C++ generation: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
