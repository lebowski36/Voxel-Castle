// filepath: /home/system-x1/Projects/Voxel Castle/voxel_fortress/src/plugins/ui.rs
use bevy::prelude::*;
use crate::chunk::ChunkManager;

/// Game states to control application flow
#[derive(Debug, Clone, Copy, Default, Eq, PartialEq, Hash, States)]
pub enum GameState {
    #[default]
    Loading,
    Playing,
    Paused,
}

/// UI plugin for Voxel Fortress
pub struct UiPlugin;

/// Component for the loading bar UI element
#[derive(Component)]
pub struct LoadingBar;

/// Component for UI text elements
#[derive(Component)]
pub struct UiText;

/// Component to mark the loading UI root
#[derive(Component)]
pub struct LoadingUiRoot;

impl Plugin for UiPlugin {
    fn build(&self, app: &mut App) {
        app
            .init_state::<GameState>()
            .add_systems(Startup, setup_ui)
            .add_systems(Update, loading_progress_ui.run_if(in_state(GameState::Loading)))
            .add_systems(Update, check_loading_complete.run_if(in_state(GameState::Loading)));
    }
}

/// Sets up the initial UI elements
fn setup_ui(mut commands: Commands) {
    // Root node for UI - covers the whole screen and centers content
    let root = commands.spawn((
        NodeBundle {
            style: Style {
                width: Val::Percent(100.0),
                height: Val::Percent(100.0),
                align_items: AlignItems::Center,
                justify_content: JustifyContent::Center,
                flex_direction: FlexDirection::ColumnReverse, // Stack items vertically, text above bar
                ..default()
            },
            background_color: Color::NONE.into(),
            z_index: ZIndex::Global(0),
            ..default()
        },
        LoadingUiRoot, // Add marker component for easier cleanup
    )).id();

    // Loading text - Placed above the loading bar
    let loading_text = commands.spawn((
        TextBundle::from_section(
            "Loading world...",
            TextStyle {
                font_size: 24.0,
                color: Color::WHITE,
                ..default()
            },
        )
        .with_style(Style {
            margin: UiRect::bottom(Val::Px(20.0)),
            ..default()
        })
        .with_text_alignment(TextAlignment::Center),
        UiText,
    )).id();

    // Loading bar container - Centered horizontally by the root node
    let bar_container = commands.spawn(
        NodeBundle {
            style: Style {
                width: Val::Percent(80.0),
                height: Val::Px(30.0),
                border: UiRect::all(Val::Px(2.0)),
                ..default()
            },
            background_color: Color::rgb(0.2, 0.2, 0.2).into(),
            border_color: Color::rgb(0.9, 0.9, 0.8).into(),
            ..default()
        }
    ).id();

    // Loading bar fill
    let bar_fill = commands.spawn((
        NodeBundle {
            style: Style {
                width: Val::Percent(0.0), // Start at 0% width
                height: Val::Percent(100.0),
                ..default()
            },
            background_color: Color::rgb(0.0, 0.5, 0.9).into(),
            ..default()
        },
        LoadingBar,
    )).id();

    // Build hierarchy
    commands.entity(bar_container).add_child(bar_fill);
    // Add children to root in desired visual order (bottom to top due to ColumnReverse)
    commands.entity(root).add_child(bar_container);
    commands.entity(root).add_child(loading_text);
}

/// Updates the loading bar based on chunk loading progress
fn loading_progress_ui(
    chunk_manager: Res<ChunkManager>,
    mut query: Query<&mut Style, With<LoadingBar>>,
) {
    // Ensure total is not zero to prevent division by zero
    let total = ((chunk_manager.radius as i64 * 2 + 1).pow(3)) as usize;
    if total == 0 { return; }

    let loaded = chunk_manager.loaded_chunks.len();
    let percent = (loaded as f32 / total as f32).min(1.0);

    for mut style in query.iter_mut() {
        style.width = Val::Percent(percent * 100.0); // Update the width property of the Style
    }
}

/// System to check if loading is complete and transition to Playing state
fn check_loading_complete(
    chunk_manager: Res<ChunkManager>,
    mut next_state: ResMut<NextState<GameState>>,
    mut commands: Commands,
    loading_ui_root_query: Query<Entity, With<LoadingUiRoot>>,
) {
    let total = ((chunk_manager.radius as i64 * 2 + 1).pow(3)) as usize;
    if total == 0 { return; } // Avoid division by zero or unnecessary checks

    let loaded = chunk_manager.loaded_chunks.len();

    // If all chunks are loaded, move to the Playing state and despawn loading UI
    if loaded >= total {
        next_state.set(GameState::Playing);

        // Despawn the loading UI root and all its children
        for root_entity in loading_ui_root_query.iter() {
            commands.entity(root_entity).despawn_recursive();
        }
    }
}
